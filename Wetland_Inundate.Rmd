---
title: "Wetland Inundate Code"
output:
  html_notebook:
    toc: yes
    toc_float: yes
---

# Code Description
Below is code for a simple inundation model. Sometimes called a bathtub model, this analysis estimates the extent and volume of inundation based on (1) specified elevation, (2) digital elevation model, and (3) location of depressional wetland. The analysis is loosely based on [Jones et al., [2018]](https://doi.org/10.1002/hyp.11405).

# Step 1: Create Synthetic DEM
Normally, you would just read in a DEM for the analysis. However, for the purposes of this tutorial, we will make our own DEM with depresional wetlands. [So, just run this code. Don't worry too much about the contents for now!] 

## 1.1 Setup your workspace
As always, setup your workspace and download appropriate packages.
```{r}
#Clear Memory
rm(list=ls(all=TRUE))

#Download packages 
library(raster)
library(sp)
library(rgdal)
library(rgeos)
library(actuar)
library(poweRlaw)
library(dplyr)
```

## 1.2 Define Variables
Define variables that describe the synthetic landscape
```{r}
#lanscape size (Note, it will be a square)
area<-1000 #ha  

#Size of cell_size cell (e.g. length of one side)
cell_size<-3 #m

#wetland depth
invert<-1 #m

#landscape slope
slope<-0.001 #m/m
```

## 1.3 Create blank raster
Create raster that using variables listed above

```{r}
#Convert units to meters
area<-area*10000 #convert to m^2

#Define coordinates
x<-matrix(0, nrow=sqrt(area)/cell_size, ncol=sqrt(area)/cell_size)
y<-matrix(0, nrow=sqrt(area)/cell_size, ncol=sqrt(area)/cell_size)
z<-matrix(0, nrow=sqrt(area)/cell_size, ncol=sqrt(area)/cell_size)

#Add coordinates
for(i in 1:(sqrt(area)/cell_size)){
  x[,i]<-i*cell_size-(cell_size/2)
  y[i,]<-i*cell_size-(cell_size/2)
  }

#Add elevation data (valley slope)
interp<-approxfun(data.frame(c(1,sqrt(area)/cell_size), c(100, 100-slope*sqrt(area))))
for(i in 1:(sqrt(area)/cell_size)){z[i,]<-interp(i)}

#Create Raster
dem <-raster(z,
              xmn=range(x)[1], xmx=range(x)[2],
              ymn=range(y)[1], ymx=range(y)[2]
)

#save dem 
dem_smooth<-dem

#clean up workspace
remove(list=c("x","y","z","i","slope"))
```

## 1.4 Add wetlands to raster
```{r}
#Determine number, size, and location of wetlands~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#determine number and size of wet
wetland_area<-area*0.10 #From Van Meter and Basu 2015 (Des Moines Lobe)

#Iterate through wetland scenarios until correct area
set.seed(1)
n.wetlands<-5
pnts<-rep(wetland_area/n.wetlands, n.wetlands)

#Randomly select location of each wetland
pnts<-data.frame(coordinates(sampleRandom(dem,n.wetlands, sp=T)), pnts)
  colnames(pnts)<-c("x","y", "area_m2")

#add wetid data
pnts<-pnts[order(-pnts$area_m2),]
pnts$WetID<-seq(1,length(pnts[,1]))

#calculate wetland volume and depth
p<-4 #shape factor from Hayashi and Kamp [200]
pnts$volume_m3<-(0.25*(pnts$area_m2/10000)^1.4742)*10000 #Equation  from Wu and Lane [2016]
pnts$max_depth_m<-(pnts$volume_m3*(1+2/p))/pnts$area_m2
  
#add z data and create shp
pnts$z<-raster::extract(dem, pnts[,c("x","y")])

#add data about the watershed depth
pnts$ws_depth<-abs(rnorm(nrow(pnts),2,0.5))

#Create Function to add wetland shape (with bathymetry)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fun<-function(WetID){
  #Setup~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #define variables
  area_max<-pnts$area_m2[pnts$WetID==WetID]
  x<-pnts$x[pnts$WetID==WetID]
  y<-pnts$y[pnts$WetID==WetID]
  z<-pnts$z[pnts$WetID==WetID]
  ws_depth<-pnts$ws_depth[pnts$WetID==WetID]
  depth<-pnts$max_depth_m[pnts$WetID==WetID]
  
  #create circle function to define circle
  circle.fun<-function(area, x, y){
    radius<-(area/pi)^.5
    circle<-seq(0, 2 * pi, length.out = 2*pi*sqrt(area/pi))
    circle<-cbind(x + radius * sin(circle), y + radius * cos(circle))
    circle
  }
  
  #Represent bathymetry with points~~~~~~~~~~~~~~~~~~~~~~~~
  #Calculate variables
  radius<-(area_max/pi)^0.5
  n<-round(radius/cell_size)
  
  #create dataframe to house points
  bath<-data.frame(matrix(0, ncol=3))
    colnames(bath)<-c("x","y","z")
  bath$x[1]<-x
  bath$y[1]<-y
  bath$z[1]<-z-depth
    
  #Add "rings" to bath df
  for(i in 1:(n+1)){
    area_ring<-pi*(i*cell_size)^2
    df<-data.frame(circle.fun(area_ring, x,y),depth*(i*cell_size/radius)^p+(z-depth))
      colnames(df)<-c("x","y","z")
    bath<-rbind(bath,df)
  }
  
  #Adjust elevation for watershed invert elevation
  bath$z<-bath$z-ws_depth
  
  #Represent watershed surface~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #Calculate variables
  ws_radius<-(area_max*10/pi)^0.5
  m<-round((ws_radius-radius)/cell_size)
  
  #create dataframe to house points
  ws<-data.frame(matrix(0, ncol=3))
  colnames(ws)<-c("x","y","z")

  #Add "rings" to ws df
  for(i in 0:m){
    area_ring<-pi*(i*cell_size+radius)^2
    df<-data.frame(circle.fun(area_ring, x,y),ws_depth/(ws_radius-radius)*(i*cell_size)+(z-ws_depth))
    colnames(df)<-c("x","y","z")
    ws<-rbind(ws,df)
  }
  ws<-ws[-1,]
  
  #Create raster of Wetland Bathymetry~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #Conbime bathymetry and ws surface
  bath<-rbind(bath,ws)
  
  #Remove points that are > current dem surface
  bath$dem<-raster::extract(dem,bath[,1:2])
  bath<-bath[bath$z<bath$dem,]
  
  #If any points are left:
  if(nrow(bath)>1){
  
    #Create gird
    wetland.grd<-rasterize(bath[,1:2], dem, bath[,3])
    
    #Create Clip
    clip<-wetland.grd*0
    clip[is.na(clip)] <- 1
    wetland.grd[is.na(wetland.grd)] <- 0
    
    #append dem
    dem<-dem*clip+wetland.grd
    
    #assign dem to the global environment
    assign('dem', dem, envir = .GlobalEnv)
  }
}

#Run function
for(i in 1:length(pnts[,1])){fun(i)}

#Smooth with raster filter
dem<-focal(dem, w=matrix(1/25,nrow=5,ncol=5)) 

```

## 1.5 Plot synthetic landscape!
Below is a plot of the synthetic landscape we will use for delineation today!
```{r, echo=F}
zData<-as.matrix(dem)
x = (cell_size * (1:nrow(zData)))    
y = (cell_size * (1:ncol(zData)))
nrzmat <- nrow(zData)
nczmat <- ncol(zData)
facetValues <- (zData[-1, -1] + zData[-1, -nczmat] + zData[-nrzmat, -1] + zData[-nrzmat, -nczmat])/4
nbcol <- 99
color <- c("grey",terrain.colors(nbcol))
facetcol <- cut(facetValues, nbcol+1)
res = persp(x, y, z = zData*50, theta = 120, phi = 45,
            col = color[facetcol],
            scale = FALSE, expand = 0.75, 
            ltheta = 75, shade = 0.75, border = NA,
            box = F, ticktype = "detailed")

```
# Step 2: Delineate Wetland Basins
Now that we have created our synthetic landscape, we can seperate it into discrete endorheic (i.e., internally draining) basins.  This step requires the use of the RPyGeo package. It's worth noting, this package has to be run on a windows machine, requires both ArcGIS and Python, and require read/write access to the hard drive. For more information, read the documentation [here](https://cran.r-project.org/web/packages/RPyGeo/RPyGeo.pdf).  